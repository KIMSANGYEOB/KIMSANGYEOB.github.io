{"pages":[],"posts":[{"title":"기술 블로그 조사 &amp; 시작","text":"정적 사이트 생성기술 블로그를 시작하기전에 Github과 연동하여 운영하고싶어 정적 사이트를 만들만한 프레임워크들을 조사했다. Jekyll 루비 기반 가장 보편적이고 인기많은 정적 사이트 제작 프레임워크 문서가 많아지면 빌드하는데 5분이상이 소요될 수 있음 다양한 테마 Hexo 자바스크립트(Node.js) 기반 한글로 번역된 문서사이트 존재(완벽하진 않음) 다양한 테마 Hugo Golang 기반 매우 빠른 빌드속도 테마는 부족 Hugo? Hexo?처음에 빠른 빌드속도가 빠른것이 장점이라고 많이 알려져 있어서 Hugo로 테스트를 진행해보았다. 하지만, Go언어 기반으로 되어있어서 Go 언어를 잘 모를시에 구조 파악이나 테마 사용 시 내 입맛대로 커스텀 하기가 쉽지 않다는 것이 느껴졌다. 현재 사용하는 언어가 자바스크립트가 주력 언어이고 관련 개발을 진행하고 있으니 Hexo를 사용하기로 마음먹었다. Hexo 설치Hexo는 Node.js 기반이기 때문에 Node.js가 설치되어있어야 한다. 글로벌하게 hexo-cli 설치한다. 1$ npm install hexo-cli -g hexo로 Blog 프로젝트를 만들어준다. 123$ hexo init blog$ cd blog$ npm install 테마적용을 위해 git clone 진행 (icarus 테마를 선택) 1$ git clone https://github.com/ppoffice/hexo-theme-icarus.git hexo 테마 themes 폴더안에 clone 받은 테마의 폴더명을 hexo-theme-icarus -&gt; icarus로 변경해준다. 루트 경로에서 _config.yml 파일을 아래처럼 수정해준다. 1theme: icarus 테마에 필요한 npm 패키지들을 설치해준다. (icarus 경우 아래 패키지들이 필요함) bulma-stylus hexo-component-inferno hexo-renderer-inferno inferno inferno-create-element 1$ npm install --save bulma-stylus hexo-component-inferno hexo-renderer-inferno inferno inferno-create-element hexo s 명령어로 로컬에서 테마가 적용됬는지 확인 1$ hexo s 후기Hexo 프레임워크와 Icarus 테마로 블로그를 생성하면서 정말 손쉽게 블로그를 구성할 수 있었고 JS기반이라 구조파악이 생각보다 단순했다. 이후에는 Icarus 테마를 커스터마이징해서 다크 모드, 레이아웃 등을 변경해 볼 계획이다.","link":"/2021/08/08/blog/"},{"title":"Git을 활용한 버전관리-1","text":"버전 관리 어떤 프로젝트에서 특정 시점 및 관리를 위해 버전을 관리하는것은 필수라고 할 수 있다. starbucks starbucks 로그인 페이지 개발본 starbucks 스크롤 버그 수정 starbucks 배포용 위에 목록처럼 여러가지의 기능이 추가되고 수정되면서 프로젝트 정보가 변경된다. 관리 및 특정 시점의 버전을 관리해야하는것은 필수적인 요소라 할 수 있는데 여러 사람과의 작업 및 규모가 클수록 관리가 힘들어진다. 이런 프로젝트의 관리를 위해 SVN, Git, … 등등의 버전 관리 시스템을 도입하여 사용하고 있다. Git Git은 컴퓨터 파일의 변경사항을 추적하고 여러 사용자들 간에 파일 작업을 조율하기위한 VCS(Version Control System) 시스템 설치git 다운로드 위 링크에서 각 운영체제에 맞는 설치 프로그램을 다운로드 후 실행하여 설치하여 터미널에서 테스트 진행 기본 명령어 12345678910111213141516171819202122232425# Mac 개행문자 설정git config --global core.autocrlf input# Windows 개행문자 설정git config --global core.autocrlf true## 사용자 정보## 커밋(버전 생성)을 위한 기본정보 등록git config --global user.name 'YOUR_NAME'git config --global user.email'YOUR_EMAIL'# 구성 확인git config --global --listgit init# 현재 프로젝트에서 변경사항 추적을 시작git add index.html# 변경사항을 추적할 특정 파일을 지정git add .# 모든 파일의 변경사항을 추적하도록 지정git commit -m 'main.js 추가'# 메세지(-m)와 함께 버전을 생성git remote add origin 'https://github.c...'# origin이란 별칭의 원격 저장소로 버전 내역 설정git push origin master# origin이란 별칭의 원격 저장소로 버전 내역 전송 현재는 사용하는 로컬 컴퓨터에만 git정보가 등록이 되어 사용하던 컴퓨터가 없으면 다시 다운로드를 받을 수 없다. 어디서든지 다시 프로젝트 정보를 다운로드 받을 수 있도록 Github 서비스를 이용한다. Github깃헙 가입하기 Singup 버튼을 통해 가입을 진행(이메일 인증이 필요함) 프로젝트 정보를 업로드 할 Repository 생성을 위해 New Repository 버튼으로 생성 진행 Github 주소 등록 업로드를 위해 Github Repository의 주소를 복제한다. 1234git remote add origin https://&quot;repository 주소&quot;# 원격(Github 저장소를 뜻) 주소를 지정하기git push origin master# 원격 저장소에 업로드 (Github로그인 관련 안내가 나오면 진행) Git 활용Git 활용 및 명령어에 대해 더 자세히 알아보자 Git Commitgit commit 명령어를 통해 수정한 내용 반영 123456git status# 현재 git 상태 확인git log# 현재 반영사항 및 커밋목록 확인git commit -m 'main.js 추가'# 메세지(-m)와 함께 버전을 생성 Git Branch 프로젝트에서 여러 개발자가 각 기능이나 어떤 부분을 맡아 개발이 진행된다면 그 부분에 맞게 Branch를 분리해서 개발을 진행할 수 있다. 1234567891011121314git branch# 브랜치 목록 확인git branch -a# 브랜치 목록과 원격저장소도 확인git branch signin# signin 브랜치 생성git checkout signin# signin 브랜치로 변경git add .# 작업사항 추적git commit -m &quot;singin 페이지 구성&quot;# 수정한 내용 반영git push origin signin# 원격 저장소의 signin 브랜치에 업로드 Git Clone 다른환경에서 작업할경우 원격저장소에 있는 프로젝트를 내려받을 수 있다. 로컬환경에 프로젝트를 내려받을 폴더나 위치를 정하고 진행하는 것을 추천한다. 1git clone &quot;Github 원격 저장소 주소&quot; 다음 글에서는 Commit Reset, Conflict, Merge 등에 대해 Git의 보다 자세한 사용법에 다룰 예정이다.","link":"/2021/09/19/git/"},{"title":"serverless-data-1","text":"AWS 서버리스 데이터 분석 시스템 아키텍쳐아래 유튜브 영상을 보고 관심이 생겨 글을 작성하게 되었다. 서버리스 데이터 분석 시스템 구축 | Part 1. 개념 및 워크 플로우 Sungmin Kim. Solutions Architect, AWS 데이터로 어떤 작업을? 네트워크 분석 추천 머신러닝 그 외… What is Architecting 어떤 문제를 풀기위해서 다양한 방법들이 있을텐데, 다양한 장단점들을 Trade-off 해서 밸런싱하는것이 아키텍팅의 중심이라고 생각할 수 있다. 꼭 어떤 방법론이나 적용법이 가장 좋은 방법이라고 단정지을 순 없다. 데이터 데이터만 가지고 가치가 있는것이 아니라 데이터를 가지고 원하는 결과 및 인사이트를 내기위하여 과정들이 필요하다. 3+1 Vs of Big Data 과거에 비해서 분석시스템이 만들기가 더 어려워졌을까? 그것은 빅데이터의 4가지 특성 어마어마게 커진 Volume 생산되는 속도의 차이 Velocity 데이터의 다양성 Variety 원하는 가치 Value 이런 복잡성 때문에 현대에 와서는 데이터분석 시스템이 복잡해지고 구축해지기 어려운 점이 있다. Structured, Unstructred, and Semi-Structured데이터의 다양한 모양 및 구조 Structred Data RDB에 잘 정의되있는 데이터 Unstructred Data 동영상, 텍스트 데이터 Semi-Structured Data CSV 데이터, JSON 데이터 Data Temperature Spectrum Hot data 빠른 빈도로 데이터 요청 응답시간이 빨라야 함 데이터의 양은 적음 In-Memory DB 사용 예시) 세션값 요청 Cold data 많은 양의 데이터 요청 응답시간은 좀 높아도 괜찮음 예시) 연말에 정산된 데이터 Warm data 상시적으로 사용하는 데이터 적당한 응답시간 모든 데이터를 동일한 스토리지, 분석 솔루션으로 처리하기 보다는 목적에 맞는 데이터의 온도에 따라 나누어서 적용하는게 바람직하다. Simpilfy Big Data Processing 아주 단순한 과정을 표현하자면 데이터 수집 데이터 저장 분석 및 프로세싱 데이터 소비 및 활용 중요한 점 데이터의 처리 속도 데이터의 볼륨의 처리 가능량 전체적인 프로세스의 비용 Business Intelligence System CRM &amp; CDC주기적으로 변경되는 데이터 저장 WEB쇼핑몰 등에서 클릭하는 데이터등을 저장 IoT사물 인터넷의 센서 데이터를 모아서 저장 다음에..다음글에서 실제 AWS 서비스 아키텍쳐를 구성하는 방안들에대해 설명이 나오는데 해당 내용으로 글을 이어나가도록 하겠다.","link":"/2021/11/29/serverless-data-1/"},{"title":"serverless-stack","text":"Docs SST 서버리스 스택(SST)은 서버리스 앱을 쉽게 구축할 수 있는 프레임워크라고 소개되어 있다. 2021-10-24일 기준으로 현재 SST는 JavaScript, TypeScript, Python, Golang 및 C#을 지원하고 있다. Language CDK Lambda JavaScript ✓ ✓ TypeScript ✓ ✓ Go Coming soon ✓ Python Coming soon ✓ C# Coming soon ✓ F# Coming soon ✓ SST 프레임워크를 사용하면 앱에서 필요한 인프라스트럭쳐를 코드로(AWS CDK 사용) 정의하고, AWS Lambda 함수를 보다 간편하게 구성할 수 있다. 디자인 원리 SST는 몇가지 핵심 원리를 가지고 설계된 프레임워크이다. 점진적 공개 구조의 설정 권한 부여 제로베이스 구성 점진적 공개서버리스 앱을 구축하기 위해 SST가 제공 하는 구성은 점진적 공개 라는 아이디어를 기반으로 한다.기본 구성이 간단하고 이해하기 쉬우며 환경파악에 용이하며, 더 복잡한 사용 사례에 대해 점진적으로 사용자가 쉽게 지정할 수 있는 장점이 있다. 구조의 설정Api Routes에 간단한 예시 123456new Api(this, &quot;Api&quot;, { routes: { &quot;GET /notes&quot;: &quot;src/list.main&quot;, &quot;POST /notes&quot;: &quot;src/create.main&quot;, },}); 이러한 형태는 정의한것을 쉽게 이해할 수 있다. 만약 커스텀한 함수 속성이 필요하다면 아래와 같이 추가할 수 있다. 123456789101112131415new Api(this, &quot;Api&quot;, { defaultFunctionProps: { srcPath: &quot;src/&quot;, environment: { tableName: table.tableName }, }, routes: { &quot;GET /notes&quot;: { function: { handler: &quot;list.main&quot;, srcPath: &quot;services/functions/&quot;, }, }, &quot;POST /notes&quot;: &quot;create.main&quot;, },}); 권한 부여 SST는 attaching function을 통해 권한을 부여한다. 아래 cronjob 설정에 대한 예를 살펴보자 1234const cron = new Cron(this, &quot;Cron&quot;, { schedule: &quot;rate(1 minute)&quot;, job: &quot;src/lambda.main&quot;,}); cronjob에 대한 접근권한을 부여에 대한 예시 123456789101112131415161718// cronjob 함수에 모든 접근권한 부여cron.attachPermissions(PermissionType.ALL);// 특정 리소스에만 접근권한 부여cron.attachPermissions([&quot;s3&quot;]);import { PolicyStatement, Effect } from &quot;@aws-cdk/aws-iam&quot;;// IAM 정책으로 권한부여cron.attachPermissions([ new PolicyStatement({ actions: [&quot;execute-api:Invoke&quot;], effect: Effect.ALLOW, resources: [ `arn:aws:execute-api:${region}:${account}:${api.httpApiId}/*`, ], }),]); 제로베이스 구성SST를 프레임워크가 탄생한 가장 큰 이유 중 하나는 서버리스 개발 환경이 항상 부족하다고 느꼈기 때문이라고 한다. 부족한 점 Live Lambda Development 가 해결하려고 하는 긴밀한 피드백 루프가 부족 여러 플러그인, Webpack, Babel, TypeScript, 테스트 프레임워크, 린터 등을 구성해야 함 설정은 종종 깨지기 쉽고 최신 상태를 유지하기 위해 별도의 프로젝트 유지 관리자에 의존 위에 부족한 점들로 인해 Serverless 환경에 많은 경험이 있는 개인 개발자라면 괜찮겠지만 더 큰 팀의 일원이거나 이제 막 서버리스를 시작하는 경우 개발 환경을 시작하고 실행하는 것이 매우 어려운 점 발생한다. SST의 설계 원칙 중 하나는 개발 환경이 기본적으로 작동하는지 확인하는 것이며, 구성이 거의 또는 전혀 필요하지 않는것이 핵심 원칙이다. Quick StartNode 환경에서 아래 명령어로 빠르게 SST 프로젝트를 생성할 수 있다. 123456789# Create your appnpx create-serverless-stack@latest my-sst-appcd my-sst-app# Start Live Lambda Developmentnpx sst start# Deploy to prodnpx sst deploy --stage prod","link":"/2021/10/24/serverless/"},{"title":"타입스크립트-1","text":"타입스크립트? Language Typed Superset of JavaScript compiles to plain JavaScript 자바스크립트 그리고 확장TypeScript는 JavaScript에 구문을 추가하여 편집기와 의 긴밀한 통합을 지원하며, 편집기에서 초기에 오류를 포착할 수 있다. 신뢰할 수 있는 결과TypeScript 코드는 JavaScript가 실행되는 모든 환경에서 실행되는 JavaScript로 변환 된다.예) 브라우저, Node.js 또는 Deno 및 앱 규모에 따른 안전TypeScript는 JavaScript를 이해하고 유형 추론을 사용 하여 추가 코드 없이도 훌륭한 도구를 제공한다. JavaScript는 웹 페이지에 사소한 상호작용을 추가하기 위한 작은 스크립팅 언어로 시작하여, 규모에 상관없이 프론트엔드와 백엔드 애플리케이션에서 선택 가능한 언어로 성장했습니다. JavaScript로 작성된 프로그램의 크기, 범위 및 복잡성은 기하급수적으로 커졌지만, 다른 코드 단위 간의 관계를 표현하는 JavaScript 언어의 능력은 그렇지 못했습니다. JavaScript의 다소 특이한 런타임 의미 체계(runtime semantics)와 더불어, 언어와 프로그램 복잡성 간의 불일치는 JavaScript 개발을 규모에 맞게 관리하기 어려운 작업으로 만들었습니다. 프로그래머들이 작성하는 가장 흔한 오류는 타입 오류이다. 다른 종류의 값이 예상되는 곳에 특정한 값이 사용된 경우이다.(이는 단순한 오타, 라이브러리 API를 이해하지 못한 것, 런타임 동작에 대한 잘못된 가정 또는 다른 오류 때문일 수 있다.) TypeScript의 목표는 JavaScript 프로그램의 정적 타입 검사자이다.(즉, 코드가 실행되기 전에 실행하고(정적), 프로그램 타입이 정확한지 확인하는 도구(타입 검사)이다.) JavaScript Short History JavaScript(ECMAScript으로도 알려져있는)는 처음에 브라우저를 위한 스크립팅 언어로 만들어졌습니다. JavaScript가 처음 나왔을 때, 수십 줄 이상의 코드를 작성하는 것은 다소 이례적인 일이었기에 웹 페이지\b 속 짧은 코드들을 위해 사용할 것으로 여겨졌습니다. 때문에, 초기 웹 브라우저들은 수십 줄 이상의 코드를 실행하는데 오래 걸렸습니다. 그러나 시간이 흘러 JS가 점점 더 유명해지면서, 웹 개발자들은 JS를 이용해 상호작용을 하는 경험을 하기 시작했습니다. 웹 브라우저 개발자들은 위와 같이 늘어나는 JS 사용량에 대하여 실행 엔진(동적 컴파일)을 최적화시키고 최적화 된 것을 이용해 할 수 있는 일(API 추가)을 확장하여 웹 개발자가 더 많이 JS를 사용할 수 있게 했습니다. 현대 웹사이트에서, 브라우저는 수십만 줄의 코드로 구성된 어플리케이션을 자주 실행합니다. 이는 정적 페이지의 간단한 네트워크로 시작해서, 모든 종류의 만족스러울만한 어플리케이션 을 위한 플랫폼으로 성장한 “웹”의 길고 점진적인 성장입니다. 이외에도, JS는 node.js를 사용하여 JS 서버들을 구현하는 것처럼, 브라우저 맥락에서 벗어나는 일에 사용하기 충분할 정도로 유명해졌습니다. “어디서든 작동됨”과 같은 JS의 성질은 교차 플랫폼(cross-platform) 개발을 위한 매력적인 선택지이기도 합니다. 오늘날 많은 개발자들은 오직 JavaScript만을 이용하여 전체 스택을 프로그래밍하고 있다. 요약하자면, 우리에게는 빠른 사용을 위해 설계되었으며 수백만 줄의 어플리케이션들을 작성하기 위해 만들어진 완벽한 도구인 JavaScript가 있습니다. 모든 언어는 각자의 별난 점 - 이상한 점과 놀랄만한 점이 있으며, JavaScript의 자랑스럽지만은 않은 시작은 많은 문제를 만들게 되었습니다. 예를 들어.. JavaScript의 동일 연산자는 (==) 인수를 강제로 변환하여(coerces), 예기치 않은 동작을 유발합니다: 123456if (&quot;&quot; == 0) { // 참입니다! 근데 왜죠??}if (1 &lt; x &lt; 3) { // *어떤* x 값이던 참입니다!} JavaScript는 또한 존재하지 않는 프로퍼티의 접근을 허용합니다: 123const obj = { width: 10, height: 15 };// 왜 이게 NaN이죠? 철자가 어렵네요!const area = obj.width * obj.heigth; 대부분의 프로그래밍 언어는 이런 종류의 오류들이 발생하면 오류를 표출해주고, 일부는 코드가 실행되기 전인 컴파일 중에 오류를 표출해줍니다. 작은 프로그램을 작성할 때에는, 이런 이상한 점들이 화를 돋구지만 관리는 가능합니다. 그러나 수백 또는 수천 줄의 어플리케이션들을 작성할 때에는, 이러한 지속적 놀라움들은 심각한 문제를 야기한다. TypeScript: 정적 타입 검사자 (TypeScript: A Static Type Checker)앞서 몇 언어는 버그가 많은 프로그램을 아예 실행시키지 않는다고 했습니다. 프로그램을 실행시키지 않으면서 코드의 오류를 검출하는 것을 정적 검사 라고 합니다. 어떤 것이 오류인지와 어떤 것이 연산 되는 값에 기인하지 않음을 정하는 것이 정적 타입 검사입니다. 정적 타입 검사자 인 TypeScript는 프로그램을 실행시키기 전에 값의 종류 를 기반으로 프로그램의 오류를 찾습니다. 예를 들어, 위의 마지막 예시에 오류가 있는 이유는 obj의 타입 때문입니다. 다음은 TypeScript에서 볼 수 있는 오류입니다: 123// @errors: 2551const obj = { width: 10, height: 15 };const area = obj.width * obj.heigth; 타입이 있는 JavaScript의 상위 집합 (A Typed Superset of JavaScript)그렇다면 TypeScript는 JavaScript와 어떤 관계일까요? 구문 (Syntax)TypeScript는 JS의 구문이 허용되는, JavaScript의 상위 집합 언어입니다. 구문은 프로그램을 만들기 위해 코드를 작성하는 방법을 의미합니다. 예를 들어, 다음 코드는 )이 없으므로 구문 오류입니다: 12// @errors: 1005let a = (4 TypeScript는 독특한 구문 때문에 JavaScript 코드를 오류로 보지 않습니다. 즉, 어떻게 작성돼있는지 모르지만 작동하는 JavaScript 코드를 TypeScript 파일에 넣어도 잘 작동합니다. 타입 (Types)그러나 TypeScript는 다른 종류의 값들을 사용할 수 있는 방법이 추가된, 타입이 있는 상위 집합입니다. 위의 obj.heigth 오류는 구문 오류가 아닌, 값의 종류(타입)를 잘못 사용해서 생긴 오류입니다. 또 다른 예시로, 아래와 같은 JavaScript 코드가 브라우저에서 실행될 때, 다음과 같은 값이 출력될 것입니다: 1console.log(4 / []); 구문적으로 옳은(syntactically-legal) 위 코드는 JavaScript에서 NaN을 출력합니다. 그러나 TypeScript는 배열로 숫자를 나누는 연산이 옳지 않다고 판단하고 오류를 발생시킵니다: 12// @errors: 2363console.log(4 / []); 실제로 어떤 일이 일어나는지 보려는 의도로 숫자를 배열로 나눌 수 있지만, 대부분은 프로그래밍 실수입니다. TypeScript의 타입 검사자는 일반적인 오류를 최대한 많이 검출하면서 올바른 프로그램을 만들 수 있게 설계되었습니다.(TypeScript가 코드를 얼마나 엄격하게 검사할 수 있는지에 대한 설정 또한 존재) 만약 JavaScript 파일의 코드를 TypeScript 코드로 옮기면, 코드를 어떻게 작성했는지에 따라 타입 오류 를 볼 수 있습니다. 이는 코드 상의 문제이거나, TypeScript가 지나치게 보수적인 것일 수 있습니다. 위와 같은 오류를 제거하기 위해 가이드는 다양한 TypeScript 구문을 추가하는 방법을 보여줍니다. 런타임 특성 (Runtime Behavior) TypeScript는 JavaScript의 런타임 특성 을 가진 프로그래밍 언어입니다. 예를 들어, JavaScript에서 0으로 나누는 행동은 런타임 예외로 처리하지 않고 Infinity값을 반환합니다. 논리적으로, TypeScript는 JavaScript 코드의 런타임 특성을 절대 변화시키지 않습니다. 즉 TypeScript가 코드에 타입 오류가 있음을 검출해도, JavaScript 코드를 TypeScript로 이동시키는 것은 같은 방식으로 실행시킬 것을 보장합니다 JavaScript와 동일한 런타임 동작을 유지하는 것은 프로그램 작동을 중단시킬 수 있는 미묘한 차이를 걱정하지 않고 두 언어 간에 쉽게 전환할 수 있도록 하기 위한 TypeScript의 기본적인 약속입니다. 삭제된 타입 (Erased Types) 개략적으로, TypeScript의 컴파일러가 코드 검사를 마치면 타입을 삭제해서 결과적으로 “컴파일된” 코드를 만듭니다. 즉 코드가 한 번 컴파일되면, 결과로 나온 일반 JS 코드에는 타입 정보가 없습니다. 타입 정보가 없는 것은 TypeScript가 추론한 타입에 따라 프로그램의 특성 을 변화시키지 않는다는 의미입니다. 결론적으로 컴파일 도중에는 타입 오류가 표출될 수 있지만, 타입 시스템 자체는 프로그램이 실행될 때 작동하는 방식과 관련이 없습니다. 마지막으로, TypeScript는 추가 런타임 라이브러리를 제공하지 않습니다. TypeScript는 프로그램은 JavaScript 프로그램과 같은 표준 라이브러리 (또는 외부 라이브러리)를 사용하므로, TypeScript 관련 프레임워크를 추가로 공부할 필요가 없습니다. 컴파일 컴파일이 필요 O 컴파일러가 필요 O 컴파일하는 시점 O 컴파일된 결과물을 실행 설치12npm i typescript -g# npm init 후 npm i typescript 명령어로 프로젝트에만 tsc 사용도 가능 Visual Studio Code 2015, 2017 이후로는 디폴트로 설치됨 환경설정12tsc --init# tsconfig.json 컴파일 시 옵션을 설정 TypeScript Compiler VS Code에 컴파일러가 내장되어 있다. 내장된 컴파일러버전은 VSCode가 업데이트 되면서 올라간다. 만약 VS Code에 내장된 버전이 아닌 프로젝트 환경 전용으로 사용하고 싶다면 npm install typesript를 package.json 쪽에 버전을 명시하여 사용할 수 있다. 레퍼런스 typescriptlang fastcampus 프론트앤드 풀패키지 강의","link":"/2021/09/25/typescript-1/"},{"title":"타입스크립트-2","text":"시작하기 전…typescriptlang in 5 minutes 위에글의 번역본을 가져와 글을 작성하였다. TypeScript for JavaScript Programmers프로그래밍 언어에서 TypeScript와 JavaScript의 관계는 다소 독특하다. TypeScript은 JavaScript 위에 레이어로서 자리잡고 있는데, JavaScript의 기능들을 제공하면서 그 위에 자체 레이어를 추가합니다. 이 레이어가 TypeScript 타입 시스템이다. JavaScript는 이미 string, number, object, undefined 같은 원시 타입을 가지고 있지만, 전체 코드베이스에 일관되게 할당되었는지는 미리 확인해 주지 않는다. TypeScript는 이 레이어로서 동작한다. 이는 이미 존재하고 잘 동작하는 JavaScript 코드는 동시에 TypeScript 코드라는 의미지만, TypeScript의 타입 검사기는 사용자가 생각한 일과 JavaScript가 실제로 하는 일 사이의 불일치를 강조할 수 있다. 이 튜토리얼은 TypeScript가 추가하는 타입 시스템 언어 확장을 이해하는데 중점을 두고 타입 시스템에 대한 5분 개요를 제공한다. 타입 추론 (Types by Inference)TypeScript는 JavaScript 언어를 알고 있으며 대부분의 경우 타입을 생성해줄 것입니다. 예를 들어 변수를 생성하면서 동시에 특정 값에 할당하는 경우, TypeScript는 그 값을 해당 변수의 타입으로 사용한다. 12let helloWorld = &quot;Hello World&quot;;// ^? JavaScript가 동작하는 방식을 이해함으로써 TypeScript는 JavaScript 코드를 받아들이면서 타입을 가지는 타입 시스템을 구축할 수 있다. 이는 코드에서 타입을 명시하기 위해 추가로 문자를 사용할 필요가 없는 타입 시스템을 제공하며, 위의 예제에서 TypeScript가 helloWorld가 string임을 알게 되는 방식이다. JavaScript와 함께 VS Code를 사용하고 작업을 할 때 편집기의 자동 완성 기능을 사용해왔을 것이다. 이는 TypeScript에 필수불가결한 JavaScript에 대한 이해가 JavaScript 작업을 개선하기 위해 내부적으로 사용되었기 때문이다. 타입 정의하기 (Defining Types)JavaScript는 다양한 디자인 패턴을 가능하게 하는 동적 언어입니다. 몇몇 디자인 패턴은 자동으로 타입을 제공하기 힘들 수 있는데 (동적 프로그래밍을 사용하고 있을 것이기 때문에) 이러한 경우에 TypeScript는 TypeScript에게 타입이 무엇이 되어야 하는지 명시 가능한 JavaScript 언어의 확장을 지원합니다. 다음은 name: string과 id: number을 포함하는 추론 타입을 가진 객체를 생성하는 예제입니다. 1234const user = { name: &quot;Hayes&quot;, id: 0,}; 이 객체의 형태를 명시적으로 나타내기 위해서는 interface 로 선언합니다. 1234interface User { name: string; id: number;} 이제 변수 선언 뒤에 : TypeName의 구문을 사용해 JavaScript 객체가 새로운 interface의 형태를 따르고 있음을 선언할 수 있습니다. 123456789interface User { name: string; id: number;}// ---cut---const user: User = { name: &quot;Hayes&quot;, id: 0,}; 해당 인터페이스에 맞지 않는 객체를 생성하면 TypeScript는 경고를 줍니다. 123456789// @errors: 2322interface User { name: string; id: number;}const user: User = { username: &quot;Hayes&quot;, id: 0,}; JavaScript는 클래스와 객체 지향 프로그래밍을 지원하기 때문에, TypeScript 또한 동일합니다. - 인터페이스는 클래스로도 선언할 수 있습니다. 12345678910111213interface User { name: string; id: number;}class UserAccount { name: string; id: number; constructor(name: string, id: number) { this.name = name; this.id = id; }}const user: User = new UserAccount(&quot;Murphy&quot;, 1); 인터페이스는 함수에서 매개변수와 리턴 값을 명시하는데 사용되기도 합니다. 123456789101112// @noErrorsinterface User { name: string; id: number;}// ---cut---function getAdminUser(): User { //...}function deleteUser(user: User) { // ...} JavaScript에서 사용할 수 있는 적은 종류의 원시 타입이 이미 있습니다.: boolean, bigint, null, number, string, symbol, object와 undefined는 인터페이스에서 사용할 수 있습니다. TypeScript는 몇 가지를 추기해 목록을 확장합니다. 예를 들어, any (무엇이든 허용합니다), unknown (이 타입을 사용하는 사람이 타입이 무엇인지 선언했는가를 확인하십시오), never (이 타입은 발생될 수 없습니다) void (undefined를 리턴하거나 리턴 값이 없는 함수). 타입을 구축하기 위한 두 가지 구문이 있다는 것을 꽤 빠르게 알 수 있을 것입니다.: Interfaces and Types - interface를 우선적으로 사용하고 특정 기능이 필요할 때 type을 사용해야 합니다. 타입 구성 (Composing Types)객체들을 조합하여 더 크고 복잡한 객체를 만드는 방법과 유사하게 TypeScript에 타입으로 이를 수행하는 도구가 있습니다. 여러가지 타입을 이용하여 새 타입을 작성하기 위해 일상적인 코드에서 가장 많이 사용되는 두 가지 코드로는 유니언(Union)과 제네릭(Generic)이 있습니다. 유니언 (Unions)유니언은 타입이 여러 타입 중 하나일 수 있음을 선언하는 방법입니다. 예를 들어, boolean 타입을 true 또는 false로 설명할 수 있습니다: 1type MyBool = true | false; 참고: MyBool위에 마우스를 올린다면, boolean으로 분류된 것을 볼 수 있습니다 - 구조적 타입 시스템의 프로퍼티며, 나중에 살펴보겠습니다. 유니언 타입이 가장 많이 사용된 사례 중 하나는 값이 다음과 같이 허용되는 string 또는 number의 리터럴집합을 설명하는 것입니다: 123type WindowStates = &quot;open&quot; | &quot;closed&quot; | &quot;minimized&quot;;type LockStates = &quot;locked&quot; | &quot;unlocked&quot;;type OddNumbersUnderTen = 1 | 3 | 5 | 7 | 9; 유니언은 다양한 타입을 처리하는 방법을 제공하는데, 예를 들어 array 또는 string을 받는 함수가 있을 수 있습니다. 123function getLength(obj: string | string[]) { return obj.length;} TypeScript는 코드가 시간에 따라 변수가 변경되는 방식을 이해하며, 이러한 검사를 사용해 타입을 골라낼 수 있습니다. Type Predicate string typeof s === “string” number typeof n === “number” boolean typeof b === “boolean” undefined typeof undefined === “undefined” function typeof f === “function” array Array.isArray(a) 예를 들어, typeof obj === “string”을 이용하여 string과 array를 구분할 수 있으며 TypeScript는 객체가 다른 코드 경로에 있음을 알게 됩니다. 12345678function wrapInArray(obj: string | string[]) { if (typeof obj === &quot;string&quot;) { return [obj];// ^? } else { return obj; }} 제네릭 (Generics)TypeScript 제네릭 시스템에 대해 자세히 알아볼 수 있지만, 1분 정도의 수준 높은 설명을 하기 위해, 제네릭은 타입에 변수를 제공하는 방법입니다. 배열이 일반적인 예시이며, 제네릭이 없는 배열은 어떤 것이든 포함할 수 있습니다. 제네릭이 있는 배열은 배열 안의 값을 설명할 수 있습니다. 123type StringArray = Array&lt;string&gt;;type NumberArray = Array&lt;number&gt;;type ObjectWithNameArray = Array&lt;{ name: string }&gt;; 제네릭을 사용하는 고유 타입을 선언할 수 있습니다: 123456789101112131415// @errors: 2345interface Backpack&lt;Type&gt; { add: (obj: Type) =&gt; void; get: () =&gt; Type;}// 이 줄은 TypeScript에 `backpack`이라는 상수가 있음을 알리는 지름길이며// const backpack: Backpack&lt;string&gt;이 어디서 왔는지 걱정할 필요가 없습니다.declare const backpack: Backpack&lt;string&gt;;// 위에서 Backpack의 변수 부분으로 선언해서, object는 string입니다.const object = backpack.get();// backpack 변수가 string이므로, add 함수에 number를 전달할 수 없습니다.backpack.add(23); 구조적 타입 시스템 (Structural Type System)TypeScript의 핵심 원칙 중 하나는 타입 검사가 값이 있는 _형태_에 집중한다는 것입니다. 이는 때때로 “덕 타이핑(duck typing)” 또는 “구조적 타이핑” 이라고 불립니다. 구조적 타입 시스템에서 두 객체가 같은 형태를 가지면 같은 것으로 간주됩니다. 123456789101112interface Point { x: number; y: number;}function printPoint(p: Point) { console.log(`${p.x}, ${p.y}`);}// &quot;12, 26&quot;를 출력합니다const point = { x: 12, y: 26 };printPoint(point); point변수는 Point타입으로 선언된 적이 없지만, TypeScript는 타입 검사에서 point의 형태와 Point의 형태를 비교합니다. 둘 다 같은 형태이기 때문에, 통과합니다. 형태 일치에는 일치시킬 객체의 필드의 하위 집합만 필요합니다. 12345678910111213141516171819// @errors: 2345interface Point { x: number; y: number;}function printPoint(p: Point) { console.log(`${p.x}, ${p.y}`);}// ---cut---const point3 = { x: 12, y: 26, z: 89 };printPoint(point3); // prints &quot;12, 26&quot;const rect = { x: 33, y: 3, width: 30, height: 80 };printPoint(rect); // prints &quot;33, 3&quot;const color = { hex: &quot;#187ABF&quot; };printPoint(color); 마지막으로, 정확하게 마무리 짓기 위해, 구조적으로 클래스와 객체가 형태를 따르는 방법에는 차이가 없습니다: 12345678910111213141516171819202122// @errors: 2345interface Point { x: number; y: number;}function printPoint(p: Point) { console.log(`${p.x}, ${p.y}`);}// ---cut---class VirtualPoint { x: number; y: number; constructor(x: number, y: number) { this.x = x; this.y = y; }}const newVPoint = new VirtualPoint(13, 56);printPoint(newVPoint); // prints &quot;13, 56&quot; 객체 또는 클래스에 필요한 모든 속성이 존재한다면, TypeScript는 구현 세부 정보에 관계없이 일치하게 봅니다.","link":"/2021/11/08/typescript-2/"},{"title":"js-proxy","text":"Proxy는 특정 객체를 감싸 프로퍼티 읽기, 쓰기와 같은 객체에 가해지는 작업을 중간에서 가로채는 객체이다. 가로채진 작업은 Proxy 자체에서 처리되기도 하고, 원래 객체가 처리하도록 그대로 전달되기도 한다. Creating a proxy object1let proxy = new Proxy(target, handler); target – 감싸게 될 객체로, 함수를 포함한 모든 객체 포함 handler – 동작을 가로채는 메서드인 ‘트랩(trap)’이 담긴 객체로, 여기서 Proxy를 설정 A simple proxy example1234567891011121314const user = { firstName: 'John', lastName: 'Doe', email: 'john.doe@example.com',}const handler = { get(target, property) { console.log(`Property ${property} has been read.`); return target[property]; }}const proxyUser = new Proxy(user, handler); 123456console.log(proxyUser.firstName);console.log(proxyUser.lastName);// Property firstName has been read.// John// Property lastName has been read.// Doe user 객체에 proxyUser로 접근할경우 get() 메서드가 호출된다. 1234user.firstName = 'Jane';console.log(proxyUser.firstName);// Property firstName has been read.// Jane user 객체를 변경하면 proxyUser에도 반영된다. 12proxyUser.lastName = 'William';console.log(user.lastName); // William proxyUser 객체를 변경해도 user에 반영된다. Proxy TrapsThe get() trap일반적으로 get() 메서드에 커스텀한 로직을 작성하여 property에 접근할 때 get() trap을 발생시킬 수 있다. 12345678910111213141516const user = { firstName: 'John', lastName: 'Doe'}const handler = { get(target, property) { return property === 'fullName' ? `${target.firstName} ${target.lastName}` : target[property]; }};const proxyUser = new Proxy(user, handler);console.log(proxyUser.fullName); // John Doe The set() trapset() trap 은 target의 property가 set될때 발생한다. 12345678910111213141516171819202122232425const user = { firstName: 'John', lastName: 'Doe', age: 20}const handler = { set(target, property, value) { if (property === 'age') { if (typeof value !== 'number') { throw new Error('Age must be a number.'); } if (value &lt; 18) { throw new Error('The user must be 18 or older.') } } target[property] = value; }};const proxyUser = new Proxy(user, handler);proxyUser.age = 'foo'; // Error: Age must be a number.proxyUser.age = '16'; // The user must be 18 or older.proxyUser.age = 21; // OK. The apply() trapapply() trap은 함수가 호출될때 발생한다. 12345678910111213141516171819202122let proxy = new Proxy(target, { apply: function(target, thisArg, args) { //... }});const user = { firstName: 'John', lastName: 'Doe'}const getFullName = function (user) { return `${user.firstName} ${user.lastName}`;}const getFullNameProxy = new Proxy(getFullName, { apply(target, thisArg, args) { return target(...args).toUpperCase(); }});console.log(getFullNameProxy(user)); // JOHN DOE proxy trap의 작동 시점 내부 메서드 핸들러 메서드 작동 시점 [[Get]] get 프로퍼티를 읽을 때 [[Set]] set 프로퍼티에 쓸 때 [[HasProperty]] has in 연산자가 동작할 때 [[Delete]] deleteProperty delete 연산자가 동작할 때 [[Call]] apply 함수를 호출할 때 [[Construct]] construct new 연산자가 동작할 때 [[GetPrototypeOf]] getPrototypeOf Object.getPrototypeOf [[SetPrototypeOf]] setPrototypeOf Object.setPrototypeOf [[IsExtensible]] isExtensible Object.isExtensible [[PreventExtensions]] preventExtensions Object.preventExtensions [[DefineOwnProperty]] defineProperty Object.defineProperty, Object.defineProperties [[GetOwnProperty]] getOwnPropertyDescriptor Object.getOwnPropertyDescriptor, for..in, Object.keys/values/entries [[OwnPropertyKeys]] ownKeys Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object/keys/values/entries 참고자료 ko.javascript.info javascripttutorial 후기js proxy는 다양한 라이브러리와 프레임워크에서 사용되고 있다고 한다. 잘 활용해서 JS 환경에서 좀 더 클린하고 효율적인 코드를 작성할 수 있지 않을까 기대를 해본다.","link":"/2021/12/13/js-proxy/"},{"title":"micro-service","text":"Micro Service 마이크로서비스 아키텍처라고도 하는 마이크로서비스는 애플리케이션을 다음과 같은 서비스 모음으로 구성하는 아키텍처 스타일이라고 할 수 있다. 그림예시) 높은 유지보수 및 테스트 가능 느슨한 결합 독립적으로 배포 가능 비즈니스 역량을 중심으로 구성 소규모 팀 소유 마이크로서비스 아키텍처를 사용하면 크고 복잡한 애플리케이션을 빠르고 자주 안정적으로 전달할 수 있으며, 또한 조직이 기술 스택을 발전시킬 수 있다. 상황예시) 서버측 엔터프라이즈 애플리케이션을 개발 중입니다. 데스크톱 브라우저, 모바일 브라우저 및 기본 모바일 애플리케이션을 비롯한 다양한 클라이언트를 지원해야 합니다. 애플리케이션은 제3자가 사용할 API를 노출할 수도 있습니다. 웹 서비스나 메시지 브로커를 통해 다른 애플리케이션과 통합할 수도 있습니다. 애플리케이션은 비즈니스 로직을 실행하여 요청(HTTP 요청 및 메시지)을 처리합니다. 데이터베이스 액세스; 다른 시스템과 메시지 교환 HTML/JSON/XML 응답을 반환합니다. 응용 프로그램의 다양한 기능 영역에 해당하는 논리적 구성 요소가 있습니다. 문제애플리케이션의 배포 아키텍처 상황 응용 프로그램에서 작업하는 개발자 팀이 있다 새로운 팀원은 신속하게 생산성을 발휘해야 한다. 응용 프로그램을 이해하고 수정하기 쉬워야 한다. 애플리케이션의 지속적인 배포를 연습하고 싶은 경우 확장성 및 가용성 요구 사항을 충족하려면 여러 컴퓨터에서 애플리케이션의 여러 인스턴스를 실행해야 한다. 새로운 기술(프레임워크, 프로그래밍 언어 등)을 활용하려는 경우 해결책느슨하게 결합된 협업 서비스 세트로 애플리케이션을 구성하는 아키텍처를 정의한다. 유지 관리 및 테스트 용이성 - 빠르고 빈번한 개발 및 배포 가능 다른 서비스와 느슨하게 결합 - 팀이 다른 서비스의 변경 사항에 영향을 받지 않고 다른 서비스에 영향을 주지 않고 대부분의 시간 동안 독립적으로 서비스 작업을 수행할 수 있습니다. 독립적으로 배포 가능 - 팀이 다른 팀과 협력하지 않고도 서비스를 배포할 수 있습니다. 소규모 팀으로 개발 가능 - 큰 팀의 높은 커뮤니케이션 헤드를 피하여 높은 생산성에 필수적 서비스는 HTTP/REST와 같은 동기 프로토콜 또는 AMQP와 같은 비동기 프로토콜을 사용하여 통신합니다. 서비스는 서로 독립적으로 개발 및 배포할 수 있습니다. 각 서비스에는 다른 서비스와 분리하기 위해 자체 데이터베이스 가 있습니다. 결과 컨텍스트이 솔루션에는 다음과 같은 많은 이점이 있다. 크고 복잡한 애플리케이션을 지속적으로 제공하고 배포할 수 있음 개선된 유지보수성 - 각 서비스가 상대적으로 작기 때문에 이해하고 변경하기 쉬움 더 나은 테스트 가능성 - 서비스는 더 작고 테스트하기 더 빠름 더 나은 배포 가능성 - 서비스를 독립적으로 배포할 수 있음 이를 통해 여러 자율적인 팀을 중심으로 개발 노력을 구성할 수 있다.각(소위 두 개의 피자) 팀은 하나 이상의 서비스를 소유하고 책임이 있습니다. 각 팀은 다른 모든 팀과 독립적으로 서비스를 개발, 테스트, 배포 및 확장할 수 있습니다. 각 마이크로 서비스는 상대적으로 작습니다. 개발자가 이해하기 쉽게 IDE는 개발자의 생산성을 더 빠르게 만듭니다. 애플리케이션이 더 빨리 시작되어 개발자의 생산성이 향상되고 배포 속도가 빨라집니다. 향상된 결함 격리. 예를 들어, 한 서비스에 메모리 누수가 있는 경우 해당 서비스만 영향을 받습니다.다른 서비스는 계속해서 요청을 처리합니다. 이에 비해 모놀리식 아키텍처의 오작동 구성 요소 중 하나는 전체 시스템을 다운시킬 수 있습니다. 기술 스택에 대한 장기적인 약속을 제거합니다. 새로운 서비스를 개발할 때 새로운 기술 스택을 선택할 수 있습니다. 마찬가지로 기존 서비스를 크게 변경할 때 새로운 기술 스택을 사용하여 다시 작성할 수 있습니다. 단점이 솔루션에는 여러 가지 단점이 있다. 개발자는 분산 시스템 생성의 추가적인 복잡성을 처리해야 합니다. 개발자는 서비스 간 통신 메커니즘을 구현하고 부분적 오류를 처리해야 합니다. 여러 서비스에 걸친 요청을 구현하는 것이 더 어렵습니다. 서비스 간의 상호 작용을 테스트하는 것이 더 어렵습니다. 여러 서비스에 걸친 요청을 구현하려면 팀 간의 세심한 조정이 필요합니다. 개발자 도구/IDE는 모놀리식 애플리케이션 구축을 지향하며 분산 애플리케이션 개발에 대한 명시적인 지원을 제공하지 않습니다. 배포 복잡성. 프로덕션 환경에는 다양한 서비스로 구성된 시스템을 배포하고 관리하는 작업의 복잡성도 있습니다. 메모리 소비 증가. 마이크로서비스 아키텍처는 N개의 모놀리식 애플리케이션 인스턴스를 NxM 서비스 인스턴스로 대체한다. 각 서비스가 일반적으로 인스턴스를 격리하는 데 필요한 자체 JVM(또는 이와 동등한 것)에서 실행되는 경우 JVM 런타임의 M배에 달하는 오버헤드가 있습니다. 또한 Netflix의 경우와 같이 각 서비스가 자체 VM(예: EC2 인스턴스)에서 실행되는 경우 오버헤드가 훨씬 더 높다. Micro Service 61. 다중 구성 요소 마이크로서비스로 구축된 소프트웨어는 정의에 따라 여러 구성 요소 서비스로 나눌 수 있다. 따라서 이러한 각 서비스는 애플리케이션의 무결성을 손상시키지 않고 독립적으로 배포, 조정 및 재배포될 수 있다.(결과적으로 전체 응용 프로그램을 다시 배포하는 대신 하나 이상의 고유한 서비스만 변경하면 된다.) 그러나 이 접근 방식에는 비용이 많이 드는 원격 호출(in-process 호출 대신), 더 세분화된 원격 API, 구성 요소 간 책임 재분배 시 복잡성 증가 등의 단점이 있다. 2. 비즈니스용으로 구축 마이크로서비스 스타일은 일반적으로 비즈니스 기능과 우선 순위를 중심으로 구성된다. 각기 다른 팀이 UI, 데이터베이스, 기술 계층 또는 서버 측 논리에 대해 특정 초점을 맞추는 기존의 모놀리식 개발 접근 방식과 달리 마이크로서비스 아키텍처는 기능 간 팀을 활용한다. 각 팀의 책임은 메시지 버스를 통해 통신하는 하나 이상의 개별 서비스를 기반으로 특정 제품을 만드는 것이다. 3. 단순 라우팅 마이크로서비스는 고전적인 UNIX 시스템과 다소 유사하게 작동한다. 요청을 수신하고 처리하고 그에 따라 응답을 생성한다. 메시지 라우팅, 구성 및 비즈니스 규칙 적용을 위한 첨단 시스템이 활용되는 ESB(Enterprise Service Buses)와 같은 다른 제품의 수와 반대이다. 마이크로 서비스에는 정보를 처리하고 논리를 적용하는 스마트 엔드포인트와 정보가 흐르는 덤 파이프가 있다고 말할 수 있다. 4. 탈중앙화 마이크로서비스는 다양한 기술과 플랫폼을 포함하기 때문에 중앙 집중식 거버넌스의 구식 방법은 최적이 아니다. 마이크로서비스 커뮤니티는 분산 거버넌스를 선호한다.(그 이유는 개발자가 유용한 도구를 생성하여 다른 사람들이 동일한 문제를 해결하는 데 사용할 수 있기 때문이다.) 분산된 거버넌스와 마찬가지로 마이크로서비스 아키텍처도 분산된 데이터 관리를 선호합니다.(모놀리식 시스템은 여러 애플리케이션에서 단일 논리 데이터베이스를 사용한다.) 마이크로 서비스 애플리케이션에서 각 서비스는 일반적으로 고유한 데이터베이스를 관리한다. 5. 고장 방지 다재다능한 아이처럼 마이크로서비스는 실패에 대처하도록 설계되었다. 여러 고유하고 다양한 서비스가 함께 통신하고 있기 때문에 서비스가 실패할 가능성이 있다.(예: 공급자를 사용할 수 없는 경우). 클라이언트는 가능한 인접 서비스가 작동하도록 허용해야 한다. 마이크로 서비스를 모니터링 하면 실패 위험을 방지하는 데 도움이 될 수 있다. 이런 요구 사항은 모놀리식 시스템 아키텍처에 비해 마이크로서비스에 더 많은 복잡성을 추가한다. 6. 진화 마이크로서비스 아키텍처는 혁신적인 설계이며, 언젠가는 애플리케이션에 액세스할 수 있는 장치 유형을 완전히 예측할 수 없는 진화적인 시스템에 이상적이다. 많은 애플리케이션은 모놀리식 아키텍처를 기반으로 시작하지만 몇 가지 예상치 못한 요구 사항이 표면화됨에 따라, API를 통해 이전 모놀리식 아키텍처와 상호 작용하는 마이크로 서비스로 천천히 개선될 수 있다. 마이크로 서비스의 찬반마이크로서비스는 만병통치약이 아니며, 이를 구현하면 이전에는 암묵적으로 드러났지만 이제는 공개되지 않은 커뮤니케이션, 팀워크 및 기타 문제를 노출할 수 있다. 그러나 마이크로서비스의 API 게이트웨이는 빌드 및 QA 시간과 노력을 크게 줄일 수 있습니다. 한 가지 일반적인 문제는 서비스 간에 스키마/검증 논리를 공유하는 것과 관련된다. B가 다른 요구 사항을 가지고 있는 경우 일부 데이터가 유효한 것으로 간주하기 위해 A가 요구하는 것이 항상 B에 적용되는 것은 아니다. 가장 좋은 권장 사항은 버전 관리를 적용하고 공유 라이브러리에 스키마를 배포하는 것이다. 라이브러리에 대한 변경 사항은 팀 간의 토론이 될 수 있으며, 또한 강력한 버전 관리에는 종속성이 발생하여 더 많은 오버헤드가 발생할 수 있습니다. 이를 극복하기 위한 가장 좋은 방법은 이전 버전과의 호환성을 계획하고 외부 서비스/팀의 회귀 테스트 를 수락하는 것일 수 있다. 이는 다른 사람의 비즈니스 프로세스를 방해한 후에가 아니라 방해 하기 전에 대화를 나누도록 해야한다. 다른 모든 것과 마찬가지로 마이크로 서비스 아키텍처가 각 서비스에 적합한지 여부는 모두 장단점이 있기 때문에 요구 사항에 따라 다를 수 있다. 정리장점 마이크로서비스 아키텍처는 개발자가 서비스를 독립적으로 개발하고 배포할 수 있는 자유를 제공한다. 마이크로 서비스는 상당히 작은 팀에서 개발할 수 있다. 다른 서비스에 대한 코드는 다른 언어로 작성할 수 있다.(많은 실무자가 권장하지 않음). 손쉬운 통합 및 자동 배포(Jenkins, Hudson 등과 같은 오픈 소스 지속적 통합 도구 사용) 개발자가 쉽게 이해하고 수정할 수 있으므로 새로운 팀원이 신속하게 생산성을 높일 수 있다. 개발자는 최신 기술을 사용할 수 있다. 코드는 비즈니스 기능을 중심으로 구성된다. 웹 컨테이너를 더 빨리 시작하므로 배포도 더 빨라진다. 애플리케이션의 특정 부분에 변경이 필요한 경우 관련 서비스만 수정하여 재배포할 수 있으며 전체 애플리케이션을 수정하고 재배포할 필요가 없다. 더 나은 오류 격리: 하나의 마이크로 서비스가 실패해도 다른 하나는 계속 작동한다.(모놀리식 애플리케이션의 문제가 있는 영역 중 하나가 전체 시스템을 위험에 빠뜨릴 수 있음) 쉽게 확장하고 타사 서비스와 통합 기술 스택에 대한 장기 약정 없음 단점 분산 배포로 인해 테스트가 복잡하고 지루할 수 있다. 서비스 수가 증가하면 정보 장벽이 생길 수 있다. 이 아키텍처는 개발자가 내결함성, 네트워크 지연을 완화하고 다양한 메시지 형식과 로드 밸런싱을 처리해야 하므로 복잡성이 추가로 발생한다. 분산 시스템이므로 노력이 중복될 수 있습니다. 서비스의 수가 증가하면 전체 제품의 통합 및 관리가 복잡해질 수 있음 모놀리식 아키텍처의 여러 복잡성 외에도 개발자는 분산 시스템의 추가적인 복잡성을 처리해야 한다. 개발자는 서비스 간의 통신 메커니즘을 구현하는 데 추가 노력을 기울여야 한다. 분산 트랜잭션을 사용하지 않고 둘 이상의 서비스에 걸쳐 있는 사용 사례를 처리하는 것은 어려울 뿐만 아니라 다른 팀 간의 커뮤니케이션과 협력을 요구한다. 후기현재 아이랩팀은 모놀리식 어플리케이션의 형태로 구성이 되어있다. 서비스 증가 및 각 업무 도메인을 분산시키기 위해 마이크로 서비스가 필요해질 수 있다. 미리 많은 사례들과 마이크로 서비스의 기본 설계, 구조, 구축방향 등을 팀내에서 지속적으로 생각해놓고 정리해놓는것 또한 필요한 일이 아닐까 생각이 든다. 참고자료 samrtbear microservices","link":"/2021/12/27/micro-service/"},{"title":"module-bundler","text":"Module Bundler는 프론트엔드 개발자들이 주로 사용하며 JavaScript 모듈을 브라우저에서 실행할 수 있는 단일 JavaScript 파일로 묶는 데 사용되는 도구이다. 최신 모듈 번들러 예시 webpack rollup fusebox parcel 다음과 같은 이유로 Module Bundler를 필요로 할 수 있다. 브라우저는 모듈 시스템을 지원하지 않지만 오늘날에는 완전히 사실이 아닙니다. 코드의 종속성 관계를 관리하는 데 도움이 되며 종속성 순서로 모듈을 로드합니다. 종속성 순서, 이미지 자산, CSS 자산 등으로 자산을 로드하는 데 도움이 됩니다. Module?Module이란 프로그래밍 관점에서 특정 기능을 갖는 작은 코드 단위를 의미합니다. JavaScript의 Simple Example 123456789101112// math.jsfunction sum(a, b) { return a + b;}function substract(a, b) { return a - b;}const pi = 3.14;export { sum, substract, pi }; 이 math.js 파일은 아래와 같이 3가지 기능을 갖고 있는 Module이다. 두 숫자의 합을 구하는 sum() 함수 두 숫자의 차를 구하는 substract() 함수 원주율 값을 갖는 pi 상수 이처럼 성격이 비슷한 기능들을 하나의 의미 있는 파일로 관리하면 Module로 취급된다. Why Need Bundler설명을 위해 여러 JavaScript 파일로 구성된 웹 응용 프로그램을 구축하는 상황을 가정해보자 아래는 필요한 JavaScript 파일을 html에 추가하는 예시 1234567&lt;html&gt; &lt;script src=&quot;/src/foo.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/src/bar.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/src/baz.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/src/qux.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/src/quux.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 각 파일에는 5개의 왕복 요청인 별도의 http 요청이 필요하다. 따라서 5개의 파일을 모두 하나로 결합할 수 있다면 더 효율적이다. 123&lt;html&gt; &lt;script src=&quot;/dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; Bundle Problem 포함될 “파일” 의 순서를 어떻게 유지? “파일” 사이에 일종의 종속성 순서가 있으면 좋음 “파일” 간의 이름 충돌을 방지하려면? 번들 내에서 사용되지 않은 “파일”을 어떻게 확인? 다음과 같이 각 파일 간의 관계를 알면 이 모든 것을 해결할 수 있습니다. 어떤 파일이 다른 파일에 종속되어 있는지? 파일에서 노출되는 인터페이스는 무엇? 어떤 노출된 인터페이스가 다른 사람에 의해 사용되고 있습니까? 부여된 이러한 정보는 각각 제기된 문제를 해결할 수 있다. 따라서 우리에게 필요한 것은 파일 간의 관계를 설명하는 선언적 방법이며, 이는 우리를 JavaScript 모듈 시스템으로 이끈다. CommonJS &amp; ES6 ModuleCommonJS 또는 ES6 모듈은 우리가 의존하고 있는 파일과 파일에서 사용 중인 인터페이스를 지정할 수 있는 방법을 제공한다. 1234567// CommonJSconst foo = require('./foo');module.exports = bar;// ES Modulesimport foo from './foo';export default bar; How Bundle? 모듈 시스템에서 수집한 정보로 어떻게 파일을 함께 연결하고 모든 것을 캡슐화하는 번들 파일을 생성할까? 대표적인 2개의 Module Bundler를 사용 webpack rollup 우리는 3개의 파일을 가지고 있다고 가정해보자 circle.js square.js app.js 1234567891011121314// filename: circle.jsconst PI = 3.141;export default function area(radius) { return PI * radius * radius;}// filename: square.jsexport default function area(side) { return side * side;}// filename: app.jsimport squareArea from './square';import circleArea from './circle';console.log('Area of square: ', squareArea(5));console.log('Area of circle', circleArea(5)); “웹팩 방식”“webpack 방식” 번들은 어떻게 생겼을까? 12345678910111213141516171819202122232425// filename: webpack-bundle.jsconst modules = { 'circle.js': function (exports, require) { const PI = 3.141; exports.default = function area(radius) { return PI * radius * radius; }; }, 'square.js': function (exports, require) { exports.default = function area(side) { return side * side; }; }, 'app.js': function (exports, require) { const squareArea = require('square.js').default; const circleArea = require('circle.js').default; console.log('Area of square: ', squareArea(5)); console.log('Area of circle', circleArea(5)); },};webpackStart({ modules, entry: 'app.js',}); 첫째, 가장 먼저 눈에 띄는 것은 Module Map 이다. 모듈 이름을 함수로 래핑된 모듈 자체에 매핑하는 사전입니다. Module Map은 항목을 추가하여 모듈을 쉽게 등록할 수 있다. 둘째, 각 모듈은 함수로 Wrapping 된다. 이 함수는 모듈 내에서 선언된 모든 것이 자체 내에서 범위가 지정되는 모듈 범위를 시뮬레이션합니다. 함수 자체를 Module Factory Function라고 합니다. 모듈이 인터페이스를 내보내고 다른 모듈에서 요구할 수 있도록 몇 가지 매개 변수를 사용한다. 셋째, 어플리케이션이 시작되고 webpackStart는 모든 것을 함께 붙여주는 함수이다. 종종 런타임 이라고 하는 함수 자체는 번들에서 가장 중요한 부분이다. 모듈 맵과 입력 모듈을 사용하여 애플리케이션을 시작한다. 1234567891011121314151617181920212223// filename: webpack-bundle.jsfunction webpackStart({ modules, entry }) { const moduleCache = {}; const require = (moduleName) =&gt; { // if in cache, return the cached version if (moduleCache[moduleName]) { return moduleCache[moduleName]; } const exports = {}; // this will prevent infinite &quot;require&quot; loop // from circular dependencies moduleCache[moduleName] = exports; // &quot;require&quot;-ing the module, // exported stuff will assigned to &quot;exports&quot; modules[moduleName](exports, require); return moduleCache[moduleName]; }; // start the program require(entry);} webpackStart require function과 module cache의 2가지를 정의한다. require 기능은 CommonJS의 기능과 다르다. require 구문은 exported interface를 module로 부터 반환한다.예시: circle.js 라면 -&gt; { default: function area(radius){ ... } } 반환 내보낸 인터페이스는 모듈 캐시에 캐시되므로 동일한 모듈 이름의 require를 반복적으로 호출하면 모듈 팩토리 함수가 한 번만 실행됩니다. require가 정의된 상태에서 애플리케이션을 시작하는 것은 입력 모듈을 “요구”하는 것뿐입니다. “롤업 방식”이제 “롤업 방식” 번들을 살펴보자. 12345678910111213// filename: rollup-bundle.jsconst PI = 3.141;function circle$area(radius) {return PI _ radius _ radius;}function square$area(side) {return side \\* side;}console.log('Area of square: ', square$area(5));console.log('Area of circle', circle$area(5)); 첫째, 롤업 번들의 주요 차이점은 웹팩 번들에 비해 훨씬 작다. “webpack 방식”에 비해 모듈 맵 이 없으며, 모든 모듈은 번들로 “평평하게” 정의된다. 모듈의 래핑 function이 없다. 모듈 내에서 선언된 모든 변수/함수는 이제 전역 범위로 선언된다. 혹시 개별 모듈 범위에서 선언된 모든 것이 전역 범위로 선언된 경우 2개의 모듈이 동일한 이름의 변수/함수를 선언한다면? 롤업은 이름 충돌이 발생하지 않도록 변수/함수 이름을 변경한다. 예시에서 circle.js and square.js는 모두 function area(){} 모듈 내에서 선언 되었으며 번들될 때 충돌을 피하기 위해 두 함수와 그 사용법이 모두 이름이 변경된 것을 볼 수 있다. 모듈을 함수로 래핑하지 않는 부작용 중 하나의 동작이다 eval. 자세한 설명 은 문서를 참조 둘째, 번들 내 모듈의 순서가 문제가 있을 수 있다. circle$area -&gt; square$area -&gt; console.log 순서대로 ​​작동하지만 temporal dead zone 때문에 PI전에 선언해야한다. 따라서 종속성 순서대로 모듈을 정렬하는 것은 “롤업 방식”에 중요하다. 대체로 “롤업 방식”이 “웹팩 방식”보다 나은 것 같아보인다. 모든 기능을 제거하여 더 작은 번들과 더 적은 런타임 오버헤드를 갖는 특징이 있다. 요약 모듈 번들러 는 여러 JavaScript 모듈을 하나의 JavaScript 파일로 결합하는 데 큰 도움이 된다. “웹팩 방식” 모듈 맵 사용 함수를 사용하여 각 모듈을 래핑 모듈을 함께 연결하는 런타임 코드가 있음 “롤업 방식” 더 평평하고 작은 묶음 모듈을 래핑하기 위해 함수를 사용하지 않음 순서 문제, 종속성을 기반으로 한 정렬 필요 순환 종속성이 작동하지 않을 수 있음 참고자료 What-is-module-bundler Webpack rollup","link":"/2021/12/21/module-bundler/"},{"title":"http-web-basic-1","text":"모든 개발자가 들어야하는 HTTP 기초 강의를 듣고 글을 작성 인터넷 네트워크 인터넷 통신 IP(Internet Protocol) TCP, UDP PORT DNS 인터넷 통신 인터넷에서 컴퓨터 둘은 어떻게 통신할까? 인터넷 구성 및 작동에대한 것은 아래 링크에서 개념적으로 배울 수 있다. mozilla How Does Internet Work 노드컴퓨터 네트워크에 있어서 노드도 네트워크에 연결되어 있는 1개 1개의 기계를 의미한다. 구체적으로는 컴퓨터부터 시작해 네트워크를 교통 정리하는 루터나 허브, 네트워크 상에 다양한 서비스를 제공하고 있는 서버, 더욱이 네트워크에 연결되어 있는 프린터나 IP전화기등에 관해서도 노드라고 부를 수 있다. 그 외에 네트워크에 연결되어 있는 것이라면 스마트폰이나 타블렛PC등의 기기도 물론 노드라고 할 수 있다. 한편 노드와 노드를 연결하고 있는 (케이블 등) 것은 ‘링크(link)’ 혹은 ‘엣지(edge)’라고 부른다. 링크와 노드, 엣지를 합쳐서 1개의 네트워크가 완성되는 것이다. ※ 엣지는 링크 중에서도 다른 네트워크와의 경계선에 있는 부분, 혹은 단말의 가장 자리에 있는 부분을 의미한다. IP(인터넷 프로토콜) 지정한 IP 주소(IP Address)에 데이터 전달 패킷(Packet)이라는 통신 단위로 데이터 전달 IP 패킷 정보 ip 패킷을 통해 데이터를 전달할 수 있다. 클라이언트 패킷 전달 출발지 100.100.100.1 목적지 200.200.200.2 내용 : Hello, World! … 서버 패킷 전달 출발 200.200.200.2 목적 100.100.100.1 OK (Response) … IP 프로토콜의 한계 비연결성 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송 비신뢰성 중간에 패킷이 사라지면? 패킷이 순서대로 안오면? 프로그램 구분 프로그램 구분 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면? 대상 서버 중단 패킷 손실 패킷 전달 순서","link":"/2022/01/03/http-web-basic-1/"},{"title":"http-web-basic-2","text":"인터넷 네트워크 TCP UDP 인터넷 프로토콜 스택의 4계층 인터넷에서 컴퓨터들이 서로 정보를 주고받는 데 쓰이는 프로토콜의 모음 어플리케이션 계층 : 프로세스간 통신을 담당. 예) HTTP, FTP, TLS/SSL 전송 계층 : 송신자와 수신자를 연결하는 서비스에 대한 정보를 담당 인터넷 계층 : 패킷을 목적지로 전송하기 위한 정보를 담당 네트워크 인터페이스 계층 : LAN드라이버, LAN 장비등을 통해 물리적 전송을 담당 프로토콜 계층 TCP 전송 제어 프로토콜(Transmission Control Protocol) 연결지향 - TCP 3 way handshake (가상 연결) 데이터 전달 보증 순서 보장 신뢰할 수 있는 프로토콜 현재는 대부분 TCP 사용 TCP 3 way handshake Data Transfer Data Order UDP 사용자 데이터그램 프로토콜(User Datagram Protocol) 하얀 도화지에 비유(기능이 거의 없음) 연결지향 - TCP 3 way handshake X 데이터 전달 보증 X 순서 보장 X 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름 HTTP/3 퀵(QUIC; Quick UDP Internet Connection)로 UDP를 사용하여 인터넷 연결을 하는 프로토콜이다. HTTP(Hyper Text Transfer Protocol)의 3번째 프로토콜이다. HTTP는 클라이언트와 서버 사이에 이루어지는 요청/응답 프로토콜이다. 클라이언트인 웹 브라우저가 이 프로토콜을 통해 서버로부터 웹 페이지나 그림 정보를 요청하면, 서버는 이 요청에 응답하여 필요한 정보를 해당 사용자에게 전달하게 되고, 이 정보가 출력 장치를 통해 사용자에게 나타나는 것이다. HTTP/3은 처음에는 HTTP-over-QUIC 이라는 이름을 가지고 있었다. 즉, QUIC 프로토콜 위에서 돌아가는 HTTP이다. TCP vs UDP TCP는 Connection 지향이며, UDP는 Connectionless 프로토콜이다. TCP는 전송 된 정보의 확인을 위해 유용한 데이터를 전송할 때 높은 신뢰성을 제공한다. 그리고 손실 패킷이있는 경우이를 다시 보낸다. UDP의 경우 패킷이 손실되면 재전송을 요구하지 않고 대상 컴퓨터가 손상된 데이터를 수신한다. 따라서 UDP는 신뢰할 수 없는 프로토콜이다. TCP는 데이터를 전송하기 전에 TCP가 연결을 설정하고 패킷의 적절한 전달을 보장하므로 UDP와 비교할 때 속도가 느리다. 반면에 UDP는 전송 된 데이터가 수신되었는지 여부를 확인하지 않는다. UDP의 헤더 크기는 8 바이트이며 TCP의 헤더 크기는 두 배 이상이다. TCP 헤더 크기는 20 바이트이므로 TCP 헤더에는 옵션, 채우기, 체크섬, 플래그, 데이터 오프셋, 확인 번호, 시퀀스 번호, 원본 및 대상 포트 등이 포함된다. TCP와 UDP는 모두 오류를 검사 할 수 있지만 TCP만이 정체와 흐름 제어를 모두 가지고 있으므로 오류를 수정할 수 있다. 비교 TCP UDP 의미 TCP는 데이터를 전송하기 전에 컴퓨터간에 연결을 설정합니다. UDP는 시스템이 수신 준비가되었는지 여부를 확인하지 않고 대상 컴퓨터에 직접 데이터를 보냅니다. 확장 대상 전송 제어 프로토콜 사용자 데이터 그램 프로토콜 연결 타입 연결 지향 연결이 적음 속도 느린 빠른 신뢰할 수 있음 높은 신뢰성 신뢰할 수 없는 헤더 크기 20 바이트 8 바이트 승인 사용자의 요청이있을 경우 데이터 확인 및 전송 재전송 기능이 있습니다. 수신 확인도 걸리지도 않고 손실 된 데이터를 다시 전송하지도 않습니다. 참고자료 gadget-info difference-between-tcp 인프런 강의","link":"/2022/01/10/http-web-basic-2/"},{"title":"http-web-basic-3","text":"PORT 같은 IP 내에서 프로세스를 구분 IP가 아파트라면 포트는 몇동 몇호라고 할 수 있다. 0 ~ 65535: 할당가능 0 ~ 1023: 잘 알려진 포트, 사용하지 않는것이 좋음 FTP - 20, 21 TELNET - 23 HTTP - 80 HTTPS - 443 인터넷 프로토콜 스위트에서 포트(port)는 운영 체제 통신의 종단점이다. 이 용어는 하드웨어 장치에도 사용되지만, 소프트웨어에서는 네트워크 서비스나 특정 프로세스를 식별하는 논리 단위이다. 주로 포트를 사용하는 프로토콜은 전송 계층 프로토콜이라 하며, 예를 들어 전송 제어 프로토콜(TCP)와 사용자 데이터그램 프로토콜(UDP)가 있다. 각 포트는 번호로 구별되며 이 번호를 포트 번호라고 한다. 포트 번호는 IP 주소와 함께 쓰여 해당하는 프로토콜에 의해 사용된다. 표기URI 문법에 의해서 사용 및 표기할 수 있으며, IP 주소와 함께 URL을 표기하는 예는 다음과 같다. ftp://000.000.000.000:21위 표기에서 ftp://는 URI 주소와 구분 기호를, 000.000.000.000은 IP 주소를 의미하며 : 다음의 21은 포트 번호를 의미한다. 포트 번호를 생략 가능한 경우가 있는데 예를 들면, http://000.000.000.000위와 같은 같은 월드 와이드 웹 URL은 기본적으로 80번 포트를 사용하므로 웹 브라우저는 자동적으로 이를 다음과 같은 의미로 처리한다. http://000.000.000.000:80 DNS 도메인 네임 시스템(Domain Name System) 전화번호부 도메인 명을 IP주소로 변환 DNS 서버 웹 페이지로드와 관련됨 DNS 리커서 - 리커서는 도서관의 어딘가에서 특정한 책을 찾아달라고 요청받는 사서로 생각할 수 있다.DNS 리커서는 웹 브라우저 등의 애플리케이션을 통해 클라이언트 컴퓨터로부터 쿼리를 받도록 고안된 서버이다.일반적으로, 리커서는 클라이언트의 DNS 쿼리를 충족시키기 위해 추가 요청을 수행한다. 루트 이름 서버 - 루트 서버는 사람이 읽을 수 있는 호스트 이름을 IP 주소로 변환(확인)하는 첫 번째 단계이다.도서관에서 책장 위치를 가리키는 색인으로 생각할 수 있으며, 일반적으로 다른 더욱 특정한 위치에 대한 참조로 사용된다. TLD 이름 서버 - TLD(최상위 도메인) 서버는 도서관의 특정 책장으로 생각할 수 있다.이 이름 서버는 특정 IP 주소 검색의 다음 단계이며 호스트 이름의 마지막 부분을 호스팅한다(example.com에서 TLD 서버는 “com”이다). 권한 있는 이름 서버 - 최종 이름 서버로서, 책장에 있는 사전처럼 특정 이름을 해당 정의로 변환합니다. 권한 있는 이름 서버는 이름 서버 쿼리의 종착점이다.권한있는 이름 서버가 요청한 레코드에 대한 액세스 권한이 있다면, 요청한 호스트 이름의 IP 주소를, 초기 요청을 한 DNS 리커서(사서)에게 돌려 보낸다. DNS 조회 8단계 사용자가 웹 브라우저에 example.com을 입력하면, 쿼리가 인터넷으로 이동하고 DNS 재귀 확인자가 이를 수신 이어서 확인자가 DNS 루트 이름 서버(.)를 쿼리 다음으로, 루트 서버가, 도메인에 대한 정보를 저장하는 최상위 도메인(TLD) DNS 서버(예: .com 또는 .net)의 주소로 확인자에 응답 이제, 확인자가 .com TLD에 요청 이어서, TLD 서버가 도메인 이름 서버(example.com)의 IP 주소로 응답 마지막으로, 재귀 확인자가 도메인의 이름 서버로 쿼리를 보냄 이제, example.com의 IP 주소가 이름 서버에서 확인자에게 반환 이어서, DNS 확인자가, 처음 요청한 도메인의 IP 주소로 웹 브라우저에 응답 참고자료 wiki port CloudFlare DNS","link":"/2022/01/16/http-web-basic-3/"},{"title":"http-web-basic-4","text":"URI(Uniform Resource Identifier)URI? URL? URN? “URI는 로케이터(locator), 이름(name) 또는 둘다 추가로 분류될 수 있다” https://www.ietf.org/rfc/rfc3986.txt - 1.1.3. URI, URL, and URN URI리소스의 위치를 뜻함 예시) 우리 회사가 A구 B동 C호에 위치하고 있다. Uniform: 리소스 식별하는 통일된 방식 Resource: 자원, URI로 식별할 수 있는 모든 것(제한 없음) Identifier: 다른 항목과 구분하는데 필요한 정보 URN리소스의 이름을 뜻함 예시) 우리 회사의 이름 URN - Name: 리소스에 이름을 부여 위치는 변할 수 있지만, 이름은 변하지 않는다. urn:isbn:8960777331 (어떤 책의 isbn URN) URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않음 URL 전체 문법 scheme://[userinfo@]host[:port][/path][?query][#fragment] https://www.google.com:443/search?q=hello&amp;hl=ko 프로토콜(https) 호스트명(www.google.com) 포트 번호(443) 패스(/search) 쿼리 파라미터(q=hello&amp;hl=ko) scheme scheme://[userinfo@]host[:port][/path][?query][#fragment] https://www.google.com:443/search?q=hello&amp;hl=ko 주로 프로토콜 사용 프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙 예) http, https, ftp 등등 http는 80 포트, https는 443 포트를 주로 사용, 포트는 생략 가능 https는 http에 보안 추가 (HTTP Secure) userinfo scheme://[userinfo@]host[:port][/path][?query][#fragment] https://www.google.com:443/search?q=hello&amp;hl=ko URL에 사용자정보를 포함해서 인증 거의 사용하지 않음 host scheme://[userinfo@]host[:port][/path][?query][#fragment] https://www.google.com:443/search?q=hello&amp;hl=ko 호스트명 도메인명 또는 IP 주소를 직접 사용가능 PORT scheme://[userinfo@]host[:port][/path][?query][#fragment] https://www.google.com`:443`/search?q=hello&amp;hl=ko 포트(PORT) 접속 포트 일반적으로 생략, 생략시 http는 80, https는 443 path scheme://[userinfo@]host[:port][/path][?query][#fragment] https://www.google.com:443`/search`?q=hello&amp;hl=ko 리소스 경로(path), 계층적 구조 예) /home/file1.jpg /members /members/100, /items/iphone12 query scheme://[userinfo@]host[:port][/path][?query][#fragment] https://www.google.com:443/search`?q=hello&amp;hl=ko` key=value 형태 ?로 시작, &amp;로 추가 가능 ?keyA=valueA&amp;keyB=valueB query parameter, query string 등으로 불림, 웹서버에 제공하는 파라미터, 문자 형태 fragment scheme://[userinfo@]host[:port][/path][?query][#fragment] https://docs.spring.io/spring-boot/docs/current/reference/html/gettingstarted.html`#getting-started-introducing-spring-boot` fragment html 내부 북마크 등에 사용 서버에 전송하는 정보 아님 웹 브라우저 요청 흐름 DNS 조회 (IP 주소 검색) HTTPS PORT 생략, 443 HTTP 요청 메시지 생성 HTTP 응답 HTTP 버전 정보 응답 코드 데이터의 형식 데이터의 길이 …","link":"/2022/01/23/http-web-basic-4/"},{"title":"http-web-basic-5","text":"HTTPHyperText Transfer Protocol 문서간의 연결을 통해 정보를 전송하는 프로토콜로 만들어졌지만.. HTTP 메세지에 모든 것을 전송 HTML, TEXT IMAGE, 음성, 영상, 파일 JSON, XML (API) 거의 모든 형태의 데이터 전송 가능 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용 HTTP History HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X HTTP/1.0 1996년: 메서드, 헤더 추가 HTTP/1.1 1997년: 가장 많이 사용, 우리에게 가장 중요한 버전 RFC2068 (1997) -&gt; RFC2616 (1999) -&gt; RFC7230~7235 (2014) HTTP/2 2015년: 성능 개선 HTTP/3 진행중: TCP 대신에 UDP 사용, 성능 개선 기반 프로토콜 TCP: HTTP/1.1, HTTP/2 UDP: HTTP/3 현재 HTTP/1.1 주로 사용 HTTP/2, HTTP/3 도 점점 증가 HTTP 특징 클라이언트 서버 구조 무상태 프로토콜(스테이스리스), 비연결성 HTTP 메시지 단순함, 확장 가능 클라이언트 서버 구조 클라이언트와 서버를 분리해 중요한 비지니스 로직과 데이터는 전부 서버에, 클라이언트에서는 UI와 사용성을 집중 Request Response 구조 클라이언트는 서버에 요청을 보내고, 응답을 대기 서버가 요청에 대한 결과를 만들어서 응답 무상태 프로토콜 서버가 클라이언트의 상태를 보존X 장점: 서버 확장성 높음(스케일 아웃) 단점: 클라이언트가 추가 데이터 전송 Stateful, Stateless 차이 상태 유지: 중간에 다른 점원으로 바뀌면 안된다.(중간에 다른 점원으로 바뀔 때 상태 정보를 다른 점원에게 미리 알려줘야 한다.) 무상태: 중간에 다른 점원으로 바뀌어도 된다. 갑자기 고객이 증가해도 점원을 대거 투입할 수 있다. 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다. 무상태는 응답 서버를 쉽게 바꿀 수 있다. -&gt; 무한한 서버 증설 가능 Stateless실무 한계 모든 것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다. 무상태 예) 로그인이 필요 없는 단순한 서비스 소개 화면 상태 유지 예) 로그인 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지 일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지 상태 유지는 최소한만 사용 비 연결성(connectionless) 서버는 연결 유지 X, 최소한의 자원 사용 HTTP는 기본이 연결을 유지하지 않는 모델 일반적으로 초 단위의 이하의 빠른 속도로 응답 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음 예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않는다. 서버 자원을 매우 효율적으로 사용할 수 있음 비 연결성 한계와 극복 TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등등 수 많은 자원이 함께 다운로드 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결 HTTP/2, HTTP/3에서 더 많은 최적화","link":"/2022/01/30/http-web-basic-5/"}],"tags":[{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"aws","slug":"aws","link":"/tags/aws/"},{"name":"serverless","slug":"serverless","link":"/tags/serverless/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"serverless-stack","slug":"serverless-stack","link":"/tags/serverless-stack/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"proxy","slug":"proxy","link":"/tags/proxy/"},{"name":"infra","slug":"infra","link":"/tags/infra/"},{"name":"module","slug":"module","link":"/tags/module/"},{"name":"bundler","slug":"bundler","link":"/tags/bundler/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"port","slug":"port","link":"/tags/port/"},{"name":"dns","slug":"dns","link":"/tags/dns/"},{"name":"internet","slug":"internet","link":"/tags/internet/"},{"name":"tcp","slug":"tcp","link":"/tags/tcp/"},{"name":"udp","slug":"udp","link":"/tags/udp/"},{"name":"uri","slug":"uri","link":"/tags/uri/"},{"name":"url","slug":"url","link":"/tags/url/"},{"name":"server","slug":"server","link":"/tags/server/"}],"categories":[{"name":"git","slug":"git","link":"/categories/git/"},{"name":"serverless","slug":"serverless","link":"/categories/serverless/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"blogs","slug":"blogs","link":"/categories/blogs/"},{"name":"infra","slug":"infra","link":"/categories/infra/"},{"name":"network","slug":"network","link":"/categories/network/"}]}